<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive 50-Member Family Tree</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Inter font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            padding: 1rem;
        }

        /* --- Pure CSS Tree Styling --- */
        .tree-root ul {
            padding-top: 20px;
            position: relative;
            transition: all 0.5s;
        }

        .tree-root li {
            text-align: center;
            list-style-type: none;
            position: relative;
            padding: 20px 5px 0 5px;
            transition: all 0.5s;
        }

        .tree-root li::before, .tree-root li::after {
            content: '';
            position: absolute;
            top: 0;
            right: 50%;
            border-top: 2px solid #6366f1; /* Indigo color for lines */
            width: 50%;
            height: 20px;
        }

        .tree-root li::after {
            left: 50%;
            border-left: 2px solid #6366f1;
        }

        .tree-root ul:first-child::before, .tree-root ul:last-child::after {
            border: none;
        }

        /* Horizontal line for siblings */
        .tree-root li:only-child::after, .tree-root li:only-child::before {
            display: none;
        }

        .tree-root li:only-child {
            padding-top: 0;
        }

        .tree-root li:first-child::before, .tree-root li:last-child::after {
            border: none;
        }

        .tree-root li:last-child::before {
            border-right: 2px solid #6366f1;
            border-radius: 0 5px 0 0;
        }

        .tree-root li:first-child::after {
            border-radius: 5px 0 0 0;
        }

        /* Vertical line from parent to child box */
        .tree-root li .member-box::before {
            content: '';
            position: absolute;
            top: -20px;
            left: 50%;
            border-left: 2px solid #6366f1;
            width: 0;
            height: 20px;
        }

        /* Root node styling (no incoming line) */
        .tree-root > li > .member-box::before {
            content: none;
        }

        /* Fix for single child lists */
        .tree-root > li > ul > li {
            display: inline-block;
            flex-grow: 1; /* For responsive horizontal spreading */
        }
    </style>
</head>
<body class="min-h-screen">

    <div class="max-w-7xl mx-auto p-4 md:p-8 bg-white shadow-xl rounded-xl">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">Family Tree Framework (50 Members)</h1>

        <!-- Tree Container: Use overflow-x-auto to handle the width of a 50-member tree -->
        <div id="tree-container" class="overflow-x-auto p-4">
            <div id="nodes-root" class="tree-root w-max mx-auto">
                <!-- Tree will be rendered here by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        // --- 1. FAMILY DATA STRUCTURE (50 MEMBERS) ---
        // This is the data you will edit. The 'name' field is what appears on the screen.
        // The 'parentId' links a member to their parent's ID.
        // Total Nodes: 50
        const maxNodes = 50;
        const familyData = [];
        familyData.push({ id: 1, name: "Root Ancestor (Generation 1)", parentId: null });

        // Programmatically generate a tree structure of 50 members.
        // Structure: Roughly a binary tree (1, 2, 4, 8, 16 nodes per generation) for the first 5 generations (31 nodes total),
        // and the remaining 19 nodes are children of the 4th generation.
        for (let id = 2; id <= maxNodes; id++) {
            let parentId;
            let generation = 0;

            if (id <= 31) {
                // G2-G5 (Binary Tree Structure)
                parentId = Math.floor(id / 2);
                generation = Math.floor(Math.log2(id)) + 1;
            } else {
                // G6 (Remaining 19 nodes) - Children of G5 (IDs 16-31)
                parentId = 16 + ((id - 32) % 16);
                generation = 6;
            }

            familyData.push({
                id: id,
                name: `[${id}] Name Here (G${generation})`,
                parentId: parentId
            });
        }

        // --- 2. CONVERT FLAT DATA TO NESTED TREE OBJECT ---
        const map = {};
        const tree = [];

        // Convert the flat array to a map for quick lookups and link children to parents
        familyData.forEach(member => {
            map[member.id] = { ...member, children: [] };
        });

        // Build the nested tree structure
        familyData.forEach(member => {
            if (member.parentId !== null && map[member.parentId]) {
                map[member.parentId].children.push(map[member.id]);
            } else if (member.parentId === null) {
                tree.push(map[member.id]); // Found a root node
            }
        });

        // --- 3. RECURSIVE HTML RENDERING ---
        /**
         * Renders the nested tree structure into HTML <ul><li> elements.
         * @param {Object} node - The current family member object.
         * @returns {string} The HTML string for the node and its children.
         */
        function renderTree(node) {
            let childrenHtml = '';
            if (node.children.length > 0) {
                // Use flexbox to horizontally align children
                childrenHtml = `<ul class="flex justify-center flex-wrap min-w-max">`;
                node.children.forEach(child => {
                    childrenHtml += `<li class="flex-shrink-0">${renderTree(child)}</li>`;
                });
                childrenHtml += `</ul>`;
            }

            // The member box styling (Tailwind classes)
            const memberBox = `
                <div id="node-${node.id}" class="member-box inline-block p-4 border border-indigo-300 bg-white rounded-lg shadow-md hover:shadow-lg transition duration-200 cursor-pointer min-w-[120px] mx-2">
                    <p class="font-semibold text-indigo-700 text-sm">${node.name}</p>
                    <p class="text-xs text-gray-500 mt-1">ID: ${node.id}</p>
                </div>
            `;

            return `
                <div>
                    ${memberBox}
                    ${childrenHtml}
                </div>
            `;
        }

        // --- 4. DISPLAY THE TREE ---
        document.addEventListener('DOMContentLoaded', () => {
            const nodesRoot = document.getElementById('nodes-root');
            if (tree.length > 0) {
                const rootNode = tree[0]; // Assuming a single main root
                
                // Root is slightly different, it needs an outer <li> wrapper to connect to the rest of the tree.
                const rootHtml = `
                    <ul class="flex justify-center p-0">
                        <li class="p-0">
                            ${renderTree(rootNode)}
                        </li>
                    </ul>
                `;
                nodesRoot.innerHTML = rootHtml;
            } else {
                nodesRoot.innerHTML = '<p class="text-center text-red-500">Error: No family data found.</p>';
            }
        });

    </script>
</body>
</html>